import { NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  try {
    const { action, projectName, code, githubToken, repoName } = await request.json()

    switch (action) {
      case 'create-repo':
        return await createGitHubRepo(projectName, code, githubToken)
      case 'update-repo':
        return await updateGitHubRepo(repoName, code, githubToken)
      case 'setup-cicd':
        return await setupCICD(repoName, githubToken)
      default:
        return NextResponse.json({ error: 'Invalid action' }, { status: 400 })
    }
  } catch (error) {
    console.error('GitHub integration error:', error)
    return NextResponse.json(
      { error: 'GitHub integration failed', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    )
  }
}

// Create a new GitHub repository with the generated code
async function createGitHubRepo(projectName: string, code: string, githubToken: string) {
  // Create repository
  const repoResponse = await fetch('https://api.github.com/user/repos', {
    method: 'POST',
    headers: {
      'Authorization': `token ${githubToken}`,
      'Content-Type': 'application/json',
      'Accept': 'application/vnd.github.v3+json'
    },
    body: JSON.stringify({
      name: projectName.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
      description: `Website generated by AI Builder - ${projectName}`,
      private: false,
      auto_init: true,
      homepage: `https://${projectName.toLowerCase().replace(/[^a-z0-9-]/g, '-')}.vercel.app`
    })
  })

  if (!repoResponse.ok) {
    const error = await repoResponse.json()
    throw new Error(`Failed to create repository: ${error.message}`)
  }

  const repo = await repoResponse.json()

  // Add files to repository
  await addFilesToRepo(repo.full_name, code, githubToken)

  // Setup Vercel integration
  await setupVercelIntegration(repo.full_name, githubToken)

  return NextResponse.json({
    success: true,
    repoUrl: repo.html_url,
    repoName: repo.full_name,
    cloneUrl: repo.clone_url
  })
}

// Add files to the GitHub repository
async function addFilesToRepo(repoName: string, code: string, githubToken: string) {
  const files = [
    {
      path: 'index.html',
      content: code
    },
    {
      path: 'README.md',
      content: `# ${repoName.split('/')[1]}

This website was generated using AI Builder - an advanced AI-powered website creation platform.

## Features
- ðŸš€ AI-generated design
- ðŸ“± Responsive layout
- âš¡ Optimized performance
- ðŸŽ¨ Modern UI/UX

## Deployment
This site is automatically deployed to Vercel on every push to the main branch.

## Generated by
[AI Builder](https://your-domain.com) - Create stunning websites with AI
`
    },
    {
      path: 'package.json',
      content: JSON.stringify({
        name: repoName.split('/')[1],
        version: '1.0.0',
        description: 'AI-generated website',
        main: 'index.html',
        scripts: {
          build: 'echo "Static site, no build needed"',
          start: 'python -m http.server 8000',
          dev: 'python -m http.server 8000'
        },
        keywords: ['ai', 'website', 'generated', 'static'],
        author: 'AI Builder',
        license: 'MIT'
      }, null, 2)
    },
    {
      path: '.github/workflows/deploy.yml',
      content: `name: Deploy to Vercel

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Deploy to Vercel
      uses: amondnet/vercel-action@v25
      with:
        vercel-token: \${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: \${{ secrets.ORG_ID }}
        vercel-project-id: \${{ secrets.PROJECT_ID }}
        working-directory: ./
`
    },
    {
      path: 'vercel.json',
      content: JSON.stringify({
        version: 2,
        builds: [
          {
            src: 'index.html',
            use: '@vercel/static'
          }
        ],
        routes: [
          {
            src: '/(.*)',
            dest: '/index.html'
          }
        ]
      }, null, 2)
    }
  ]

  for (const file of files) {
    await fetch(`https://api.github.com/repos/${repoName}/contents/${file.path}`, {
      method: 'PUT',
      headers: {
        'Authorization': `token ${githubToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        message: `Add ${file.path}`,
        content: Buffer.from(file.content).toString('base64')
      })
    })
  }
}

// Update existing repository with new code
async function updateGitHubRepo(repoName: string, code: string, githubToken: string) {
  // Get current file SHA
  const fileResponse = await fetch(`https://api.github.com/repos/${repoName}/contents/index.html`, {
    headers: {
      'Authorization': `token ${githubToken}`,
      'Accept': 'application/vnd.github.v3+json'
    }
  })

  const fileData = await fileResponse.json()

  // Update the file
  const updateResponse = await fetch(`https://api.github.com/repos/${repoName}/contents/index.html`, {
    method: 'PUT',
    headers: {
      'Authorization': `token ${githubToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      message: 'Update website code via AI Builder',
      content: Buffer.from(code).toString('base64'),
      sha: fileData.sha
    })
  })

  if (!updateResponse.ok) {
    throw new Error('Failed to update repository')
  }

  return NextResponse.json({
    success: true,
    message: 'Repository updated successfully',
    commitUrl: (await updateResponse.json()).commit.html_url
  })
}

// Setup CI/CD pipeline
async function setupCICD(repoName: string, githubToken: string) {
  // Enable GitHub Actions
  const actionsResponse = await fetch(`https://api.github.com/repos/${repoName}/actions/permissions`, {
    method: 'PUT',
    headers: {
      'Authorization': `token ${githubToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      enabled: true,
      allowed_actions: 'all'
    })
  })

  return NextResponse.json({
    success: true,
    message: 'CI/CD pipeline configured successfully'
  })
}

// Setup Vercel integration (webhook)
async function setupVercelIntegration(repoName: string, githubToken: string) {
  // Create webhook for Vercel deployment
  const webhookResponse = await fetch(`https://api.github.com/repos/${repoName}/hooks`, {
    method: 'POST',
    headers: {
      'Authorization': `token ${githubToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      name: 'web',
      active: true,
      events: ['push', 'pull_request'],
      config: {
        url: 'https://api.vercel.com/v1/integrations/deploy-hooks/your-hook-id',
        content_type: 'json'
      }
    })
  })

  return webhookResponse.ok
}

// Get repository information
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const githubToken = searchParams.get('githubToken')
    const repoName = searchParams.get('repoName')

    if (!githubToken || !repoName) {
      return NextResponse.json({ error: 'Missing parameters' }, { status: 400 })
    }

    const response = await fetch(`https://api.github.com/repos/${repoName}`, {
      headers: {
        'Authorization': `token ${githubToken}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    })

    if (!response.ok) {
      throw new Error('Repository not found')
    }

    const repo = await response.json()

    // Get latest commits
    const commitsResponse = await fetch(`https://api.github.com/repos/${repoName}/commits?per_page=5`, {
      headers: {
        'Authorization': `token ${githubToken}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    })

    const commits = await commitsResponse.json()

    return NextResponse.json({
      success: true,
      repo: {
        name: repo.name,
        fullName: repo.full_name,
        url: repo.html_url,
        stars: repo.stargazers_count,
        forks: repo.forks_count,
        language: repo.language,
        updatedAt: repo.updated_at
      },
      commits: commits.map((commit: any) => ({
        sha: commit.sha.substring(0, 7),
        message: commit.commit.message,
        author: commit.commit.author.name,
        date: commit.commit.author.date,
        url: commit.html_url
      }))
    })

  } catch (error) {
    console.error('GitHub API error:', error)
    return NextResponse.json(
      { error: 'Failed to fetch repository information' },
      { status: 500 }
    )
  }
}
